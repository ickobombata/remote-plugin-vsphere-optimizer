export type Entries<T> = {
    [K in keyof T]: [K, T[K]];
}[keyof T][];
export declare const asError: (error: unknown) => Error;
export declare const isDefined: <Item>(item: Item | undefined) => item is Item;
export declare const isError: <Item>(item: Error | Item) => item is Error;
export declare const isTruthy: <Item>(item: false | 0 | Item | null | undefined) => item is Item;
export declare const removeEmptyMembers: <T extends Record<string, unknown>>(items: T) => T;
export declare const separateErrors: <Item>(mixed: (Error | Item)[]) => [Error[], Item[]];
export type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> & {
    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;
}[Keys];
export declare const uniqueFromSources: <T>(...sources: (T | T[] | undefined)[]) => T[];
export declare const parseJson: (text: string) => any;
