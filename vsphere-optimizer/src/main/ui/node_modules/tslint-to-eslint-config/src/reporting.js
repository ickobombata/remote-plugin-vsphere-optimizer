"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.logObsoleteRules = exports.logMissingConversionTarget = exports.logFailedConversions = exports.logSuccessfulConversions = exports.logErrorResult = void 0;
const chalk_1 = __importDefault(require("chalk"));
const os_1 = require("os");
const types_1 = require("./types");
const logErrorResult = (result, logger) => {
    switch (result.status) {
        case types_1.ResultStatus.ConfigurationError:
            logger.stderr.write(chalk_1.default.redBright("âŒ "));
            logger.stderr.write(chalk_1.default.red("Could not start tslint-to-eslint:"));
            logger.stderr.write(chalk_1.default.redBright(` âŒ${os_1.EOL}`));
            for (const complaint of result.complaints) {
                logger.stderr.write(chalk_1.default.yellowBright(`  ${complaint}${os_1.EOL}`));
            }
            break;
        case types_1.ResultStatus.Failed:
            logger.stderr.write(chalk_1.default.redBright("âŒ "));
            logger.stderr.write(chalk_1.default.red(`${result.errors.length} error`));
            logger.stderr.write(chalk_1.default.red(result.errors.length === 1 ? "" : "s"));
            logger.stderr.write(chalk_1.default.red(" running tslint-to-eslint:"));
            logger.stderr.write(chalk_1.default.redBright(` âŒ${os_1.EOL}`));
            for (const error of result.errors) {
                logger.stderr.write(chalk_1.default.gray(`  ${error.stack}${os_1.EOL}`));
            }
            break;
    }
};
exports.logErrorResult = logErrorResult;
const logSuccessfulConversions = (conversionTypeName, action, quantity, logger) => {
    logger.stdout.write(chalk_1.default.greenBright(`${os_1.EOL}âœ¨ ${quantity}`));
    logger.stdout.write(quantity === 1
        ? chalk_1.default.green(` ${conversionTypeName} ${action} with its ESLint equivalent.`)
        : chalk_1.default.green(` ${conversionTypeName}s ${action} with their ESLint equivalents.`));
    logger.stdout.write(chalk_1.default.greenBright(` âœ¨${os_1.EOL}`));
};
exports.logSuccessfulConversions = logSuccessfulConversions;
const logFailedConversions = (failed, logger) => {
    logger.stderr.write(`${chalk_1.default.redBright(`${os_1.EOL}âŒ ${failed.length}`)}`);
    logger.stderr.write(chalk_1.default.red(` error${failed.length === 1 ? "" : "s"}`));
    logger.stderr.write(chalk_1.default.red(" thrown."));
    logger.stderr.write(chalk_1.default.redBright(` âŒ${os_1.EOL}`));
    logger.info.write(failed.join("\n\n") + "\n\n");
    logger.stderr.write(chalk_1.default.red(`  Check ${logger.debugFileName} for details.${os_1.EOL}`));
};
exports.logFailedConversions = logFailedConversions;
const logMissingConversionTarget = (conversionTypeName, missingOutputMapping, missing, logger, additionalWarnings = []) => {
    const headline = missing.length === 1
        ? ` ${conversionTypeName} is not known by tslint-to-eslint-config to have an ESLint equivalent`
        : ` ${conversionTypeName}s are not known by tslint-to-eslint-config to have ESLint equivalents`;
    logger.stdout.write(chalk_1.default.yellowBright(`ï¸${os_1.EOL}â“ ${missing.length}`));
    logger.stdout.write(chalk_1.default.yellow(`${headline}.`));
    logger.stdout.write(chalk_1.default.yellowBright(` â“${os_1.EOL}`));
    for (const warning of additionalWarnings) {
        logger.stdout.write(chalk_1.default.yellow(`  ${warning}${os_1.EOL}`));
    }
    logger.stdout.write(chalk_1.default.yellow(`  Check ${logger.debugFileName} for details.${os_1.EOL}`));
    logger.info.write(`${missing.length}${headline}:${os_1.EOL}`);
    logger.info.write(missing
        .map((conversion) => `  * tslint-to-eslint-config does not know the ESLint equivalent for TSLint's "${missingOutputMapping(conversion)}".${os_1.EOL}`)
        .join(""));
    logger.info.write(os_1.EOL);
};
exports.logMissingConversionTarget = logMissingConversionTarget;
const logObsoleteRules = (ruleNames, logger) => {
    const headline = ruleNames.length === 1
        ? ` rule is obsolete and does not have an ESLint equivalent`
        : ` rules are obsolete and do not have ESLint equivalents`;
    logger.stdout.write(chalk_1.default.magentaBright(`ï¸${os_1.EOL}ðŸ¦– ${ruleNames.length}`));
    logger.stdout.write(chalk_1.default.magenta(`${headline}.`));
    logger.stdout.write(chalk_1.default.magentaBright(` ðŸ¦–${os_1.EOL}`));
    logger.stdout.write(chalk_1.default.magenta(`  Check ${logger.debugFileName} for details.${os_1.EOL}`));
    logger.info.write(ruleNames.map((ruleName) => `  * ${ruleName}${os_1.EOL}`).join(""));
    logger.info.write(os_1.EOL);
};
exports.logObsoleteRules = logObsoleteRules;
//# sourceMappingURL=reporting.js.map