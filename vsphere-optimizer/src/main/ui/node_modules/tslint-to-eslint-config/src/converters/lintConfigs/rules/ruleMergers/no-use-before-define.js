"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeNoUseBeforeDefine = void 0;
const assignWith_1 = __importDefault(require("lodash/assignWith"));
const isObject_1 = __importDefault(require("lodash/isObject"));
const NO_USE_BEFORE_DEFINE_DEFAULT_OPTS = {
    classes: true,
    enums: true,
    functions: true,
    ignoreTypeReferences: true,
    typedefs: true,
    variables: true,
};
const mergeNoUseBeforeDefine = (existingOptions, newOptions) => {
    const existingSingleOption = existingOptions === null || existingOptions === void 0 ? void 0 : existingOptions[0];
    const newSingleOption = newOptions === null || newOptions === void 0 ? void 0 : newOptions[0];
    if (existingSingleOption === undefined && newSingleOption === undefined) {
        return [];
    }
    // when not explicitly opting out with a flag assume that the option is requesting at least that flag
    if ((existingSingleOption === undefined && isOnlyTrueFlags(newSingleOption)) ||
        (newSingleOption === undefined && isOnlyTrueFlags(existingSingleOption))) {
        return [];
    }
    return [
        (0, assignWith_1.default)({}, NO_USE_BEFORE_DEFINE_DEFAULT_OPTS, existingSingleOption, newSingleOption, (currentValue, newValue) => {
            if (currentValue === undefined) {
                return newValue;
            }
            // when merging the flags always keep the opted out (false) flags
            return !!currentValue && !!newValue;
        }),
    ];
};
exports.mergeNoUseBeforeDefine = mergeNoUseBeforeDefine;
function isOnlyTrueFlags(flagsObject) {
    return (0, isObject_1.default)(flagsObject) && Object.values(flagsObject).every((flag) => !!flag);
}
//# sourceMappingURL=no-use-before-define.js.map