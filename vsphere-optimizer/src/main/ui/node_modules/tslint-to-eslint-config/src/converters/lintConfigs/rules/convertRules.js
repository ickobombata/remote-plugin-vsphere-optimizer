"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertRules = void 0;
const isEqual_1 = __importDefault(require("lodash/isEqual"));
const conversionError_1 = require("../../../errors/conversionError");
const utils_1 = require("../../../utils");
const convertRule_1 = require("./convertRule");
const convertTSLintRuleSeverity_1 = require("./formats/convertTSLintRuleSeverity");
const formatRawTslintRule_1 = require("./formats/formatRawTslintRule");
/**
 * Converts raw TSLint rules to their ESLint equivalents.
 * @see `/docs/Architecture/Linters.md` for documentation.
 */
const convertRules = (dependencies, rawTslintRules, ruleEquivalents) => {
    var _a;
    const converted = new Map();
    const failed = [];
    const missing = [];
    const obsolete = new Set();
    const plugins = new Set();
    if (rawTslintRules !== undefined) {
        for (const [ruleName, value] of Object.entries(rawTslintRules)) {
            // 1. The raw TSLint rule is converted to a standardized format.
            const tslintRule = (0, formatRawTslintRule_1.formatRawTslintRule)(ruleName, value);
            // 2. The appropriate converter is run for the rule.
            const conversion = (0, convertRule_1.convertRule)(tslintRule, dependencies.ruleConverters);
            // 3. If the rule is missing or obsolete, or the conversion failed, this is marked.
            if (conversion === undefined) {
                if (tslintRule.ruleSeverity !== "off") {
                    missing.push(tslintRule);
                }
                continue;
            }
            if (conversion instanceof conversionError_1.ConversionError) {
                failed.push(conversion);
                continue;
            }
            if (!conversion.rules) {
                obsolete.add(tslintRule.ruleName);
                continue;
            }
            const equivalents = new Set();
            // 4. For each output rule equivalent given by the conversion:
            for (const changes of conversion.rules) {
                // 4a. The output rule name is added to the TSLint rule's equivalency set.
                equivalents.add(changes.ruleName);
                // 4b. The TSLint rule's config severity is mapped to its ESLint equivalent.
                const existingConversion = converted.get(changes.ruleName);
                const newConversion = {
                    ...changes,
                    ruleSeverity: (_a = changes.ruleSeverity) !== null && _a !== void 0 ? _a : (0, convertTSLintRuleSeverity_1.convertTSLintRuleSeverity)(tslintRule.ruleSeverity),
                };
                // 4c. If this is the first time the output ESLint rule is seen, it's directly marked as converted.
                if (existingConversion === undefined) {
                    converted.set(changes.ruleName, newConversion);
                    continue;
                }
                // 4d. Notices are merged and deduplicated.
                existingConversion.notices = (0, utils_1.uniqueFromSources)(existingConversion.notices, newConversion.notices);
                converted.set(changes.ruleName, existingConversion);
                // 4e. If the existing output has the same arguments as the new output, merge lookups are skipped.
                if ((0, isEqual_1.default)(existingConversion.ruleArguments, newConversion.ruleArguments)) {
                    continue;
                }
                // 4f. If not, a rule merger is run to combine it with its existing output settings.
                const merger = dependencies.ruleMergers.get(changes.ruleName);
                if (merger === undefined) {
                    failed.push(conversionError_1.ConversionError.forMerger(changes.ruleName));
                }
                else {
                    converted.set(changes.ruleName, {
                        ...existingConversion,
                        ruleArguments: merger(existingConversion.ruleArguments, newConversion.ruleArguments),
                    });
                }
            }
            if (conversion.plugins !== undefined) {
                for (const newPlugin of conversion.plugins) {
                    plugins.add(newPlugin);
                }
            }
            ruleEquivalents.set(tslintRule.ruleName, Array.from(equivalents));
        }
    }
    return { converted, failed, missing, obsolete, plugins, ruleEquivalents };
};
exports.convertRules = convertRules;
//# sourceMappingURL=convertRules.js.map