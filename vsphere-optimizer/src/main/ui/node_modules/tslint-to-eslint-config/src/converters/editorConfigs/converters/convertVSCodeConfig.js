"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertVSCodeConfig = void 0;
const path = __importStar(require("path"));
const typescript_1 = __importDefault(require("typescript"));
const utils_1 = require("../../../utils");
const knownMissingSettings = [
    "tslint.alwaysShowRuleFailuresAsWarnings",
    "tslint.exclude",
    "tslint.ignoreDefinitionFiles",
    "tslint.jsEnable",
    "tslint.suppressWhileTypeErrorsPresent",
];
const convertVSCodeConfig = (rawEditorSettings, settings) => {
    var _a;
    const editorSettings = (0, utils_1.parseJson)(rawEditorSettings);
    const missing = knownMissingSettings.filter((setting) => editorSettings[setting]);
    const autoFixOnSave = editorSettings["editor.codeActionsOnSave"] &&
        typeof editorSettings["editor.codeActionsOnSave"] === "object" &&
        ((_a = editorSettings["editor.codeActionsOnSave"]) === null || _a === void 0 ? void 0 : _a["source.fixAll.tslint"]);
    // Only create a new config file path if the input and output configs roughly match
    const eslintPathMatches = editorSettings["tslint.configFile"] &&
        typeof editorSettings["tslint.configFile"] === "string" &&
        !path.relative(path.dirname(editorSettings["tslint.configFile"]), path.dirname(settings.config));
    // We can bail without making changes if there are no changes we need to make
    if (!autoFixOnSave && !eslintPathMatches) {
        return { contents: rawEditorSettings, missing };
    }
    // Since we've found at least one matching setting, we know the source structure is a proper {}
    const sourceFile = typescript_1.default.createSourceFile("settings.json", rawEditorSettings, typescript_1.default.ScriptTarget.Latest, 
    /*setParentNodes*/ true, typescript_1.default.ScriptKind.JSON);
    const jsonRoot = sourceFile.statements[0]
        .expression;
    const propertyIndexByName = (properties, name) => properties.findIndex((property) => property.name && typescript_1.default.isStringLiteral(property.name) && property.name.text === name);
    const transformer = (context) => (rootNode) => {
        const upsertProperties = (node, additions) => {
            const originalProperties = node.properties;
            for (const [parent, setting, value] of additions) {
                const createNewChild = (properties) => {
                    return context.factory.createPropertyAssignment(`"${parent}"`, context.factory.createObjectLiteralExpression([
                        ...(properties !== null && properties !== void 0 ? properties : []),
                        context.factory.createPropertyAssignment(`"${setting}"`, typeof value === "string"
                            ? context.factory.createStringLiteral(value)
                            : context.factory.createTrue()),
                    ], true));
                };
                const existingIndex = propertyIndexByName(originalProperties, parent);
                if (existingIndex !== -1) {
                    const existingProperty = originalProperties[existingIndex];
                    const updatedProperties = [...node.properties];
                    // We know these casts should be safe because we previously found a matching parent object for the property
                    updatedProperties[existingIndex] = createNewChild(existingProperty
                        .initializer.properties);
                    node = context.factory.createObjectLiteralExpression(updatedProperties, true);
                }
                else {
                    node = context.factory.createObjectLiteralExpression([...node.properties, createNewChild()], true);
                }
            }
            return node;
        };
        const visit = (node) => {
            node = typescript_1.default.visitEachChild(node, visit, context);
            if (node !== jsonRoot) {
                return node;
            }
            const additions = [];
            if (autoFixOnSave !== undefined) {
                additions.push([
                    "editor.codeActionsOnSave",
                    "eslint.autoFixOnSave",
                    autoFixOnSave,
                ]);
            }
            if (eslintPathMatches !== undefined) {
                additions.push(["eslint.options", "configFile", settings.config]);
            }
            return upsertProperties(jsonRoot, additions);
        };
        return typescript_1.default.visitNode(rootNode, visit);
    };
    const printer = typescript_1.default.createPrinter(undefined);
    const result = typescript_1.default.transform(sourceFile, [transformer]);
    const contents = printer
        .printFile(result.transformed[0])
        .replace(/^\(/giu, "")
        .replace(/\);(\r\n|\r|\n)*$/giu, "$1");
    result.dispose();
    return { contents, missing };
};
exports.convertVSCodeConfig = convertVSCodeConfig;
//# sourceMappingURL=convertVSCodeConfig.js.map