/*
 * Copyright (c) 2016-2022 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Component, ContentChild, ElementRef, Inject, NgZone, PLATFORM_ID, ViewChild } from '@angular/core';
import { ClrCommonStringsService } from '../../utils/i18n/common-strings.service';
import { UNIQUE_ID, UNIQUE_ID_PROVIDER } from '../../utils/id-generator/id-generator.service';
import { ClrAlignment } from '../../utils/popover/enums/alignment.enum';
import { ClrAxis } from '../../utils/popover/enums/axis.enum';
import { ClrSide } from '../../utils/popover/enums/side.enum';
import { ClrPopoverEventsService } from '../../utils/popover/providers/popover-events.service';
import { ClrPopoverPositionService } from '../../utils/popover/providers/popover-position.service';
import { ClrPopoverToggleService } from '../../utils/popover/providers/popover-toggle.service';
import { ClrDatagridColumnToggleButton } from './datagrid-column-toggle-button';
import { ClrDatagridColumnToggleTitle } from './datagrid-column-toggle-title';
import { DatagridColumnChanges } from './enums/column-changes.enum';
import { ColumnsService } from './providers/columns.service';
/** @deprecated since 2.0, remove in 3.0 */
export class ClrDatagridColumnToggle {
    constructor(commonStrings, columnsService, columnSwitchId, platformId, zone, popoverId) {
        this.commonStrings = commonStrings;
        this.columnsService = columnsService;
        this.columnSwitchId = columnSwitchId;
        this.platformId = platformId;
        this.zone = zone;
        this.popoverId = popoverId;
        // Smart Popover
        this.smartPosition = {
            axis: ClrAxis.VERTICAL,
            side: ClrSide.BEFORE,
            anchor: ClrAlignment.START,
            content: ClrAlignment.START,
        };
    }
    get allColumnsVisible() {
        return this._allColumnsVisible;
    }
    set allColumnsVisible(value) {
        this._allColumnsVisible = value;
    }
    get hideableColumnStates() {
        const hideables = this.columnsService.columns.filter(column => column.value.hideable);
        return hideables.map(column => column.value);
    }
    get hasOnlyOneVisibleColumn() {
        const nbNonHideableColumns = this.columnsService.columns.length - this.hideableColumnStates.length;
        // this should only return true when there is no non-hideable columns.
        return (nbNonHideableColumns === 0 && this.hideableColumnStates.filter(columnState => !columnState.hidden).length === 1);
    }
    toggleColumnState(columnState, event) {
        const columnToToggle = this.columnsService.columns.filter(column => column.value === columnState)[0];
        this.columnsService.emitStateChange(columnToToggle, {
            hidden: event,
            changes: [DatagridColumnChanges.HIDDEN],
        });
    }
    toggleSwitchPanel() {
        this.openState = !this.openState;
    }
    allColumnsSelected() {
        this.allSelectedElement.nativeElement.focus();
    }
    // Without tracking the checkboxes get rerendered on model update, which leads
    // to loss of focus after checkbox toggle.
    trackByFn(index) {
        return index;
    }
}
ClrDatagridColumnToggle.decorators = [
    { type: Component, args: [{
                selector: 'clr-dg-column-toggle',
                template: `
    <button
      role="button"
      type="button"
      class="btn btn-sm btn-link column-toggle--action"
      clrPopoverAnchor
      clrPopoverOpenCloseButton
      [attr.aria-controls]="popoverId"
      [attr.aria-owns]="popoverId"
      [attr.title]="commonStrings.keys.pickColumns"
    >
      <cds-icon shape="view-columns" aria-hidden="true" [attr.title]="commonStrings.keys.pickColumns"></cds-icon>
    </button>
    <div
      class="column-switch"
      role="dialog"
      [attr.aria-label]="commonStrings.keys.showColumnsMenuDescription"
      [id]="popoverId"
      clrFocusTrap
      *clrPopoverContent="openState; at: smartPosition; outsideClickToClose: true; scrollToClose: true"
    >
      <div class="switch-header">
        <div class="clr-sr-only" tabindex="-1" #allSelected>{{ commonStrings.keys.allColumnsSelected }}</div>
        <ng-container *ngIf="!customToggleTitle">
          <h2>{{ commonStrings.keys.showColumns }}</h2>
        </ng-container>
        <ng-content select="clr-dg-column-toggle-title"></ng-content>
        <button
          class="btn btn-sm btn-link toggle-switch-close-button"
          clrPopoverCloseButton
          type="button"
          [attr.aria-label]="commonStrings.keys.close"
          [attr.title]="commonStrings.keys.close"
        >
          <cds-icon shape="window-close" aria-hidden="true" [attr.title]="commonStrings.keys.close"></cds-icon>
        </button>
      </div>
      <ul class="switch-content list-unstyled">
        <li *ngFor="let columnState of hideableColumnStates; trackBy: trackByFn">
          <clr-checkbox-wrapper>
            <input
              clrCheckbox
              type="checkbox"
              [disabled]="hasOnlyOneVisibleColumn && !columnState.hidden"
              [ngModel]="!columnState.hidden"
              (ngModelChange)="toggleColumnState(columnState, !$event)"
            />
            <label>
              <ng-template [ngTemplateOutlet]="columnState.titleTemplateRef"></ng-template>
            </label>
          </clr-checkbox-wrapper>
        </li>
      </ul>
      <div class="switch-footer">
        <ng-content select="clr-dg-column-toggle-button"></ng-content>
        <clr-dg-column-toggle-button *ngIf="!customToggleButton" (clrAllSelected)="allColumnsSelected()">
          {{ commonStrings.keys.selectAll }}
        </clr-dg-column-toggle-button>
      </div>
    </div>
  `,
                host: { '[class.column-switch-wrapper]': 'true', '[class.active]': 'openState' },
                providers: [UNIQUE_ID_PROVIDER, ClrPopoverEventsService, ClrPopoverPositionService, ClrPopoverToggleService]
            },] }
];
ClrDatagridColumnToggle.ctorParameters = () => [
    { type: ClrCommonStringsService },
    { type: ColumnsService },
    { type: String, decorators: [{ type: Inject, args: [UNIQUE_ID,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: NgZone },
    { type: String, decorators: [{ type: Inject, args: [UNIQUE_ID,] }] }
];
ClrDatagridColumnToggle.propDecorators = {
    customToggleTitle: [{ type: ContentChild, args: [ClrDatagridColumnToggleTitle,] }],
    customToggleButton: [{ type: ContentChild, args: [ClrDatagridColumnToggleButton,] }],
    allSelectedElement: [{ type: ViewChild, args: ['allSelected', { read: ElementRef },] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YWdyaWQtY29sdW1uLXRvZ2dsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXIvc3JjL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtY29sdW1uLXRvZ2dsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7OztHQUlHO0FBRUgsT0FBTyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUU1RyxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSx5Q0FBeUMsQ0FBQztBQUNsRixPQUFPLEVBQUUsU0FBUyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sK0NBQStDLENBQUM7QUFDOUYsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDBDQUEwQyxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUM5RCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFFOUQsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sc0RBQXNELENBQUM7QUFDL0YsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sd0RBQXdELENBQUM7QUFDbkcsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sc0RBQXNELENBQUM7QUFDL0YsT0FBTyxFQUFFLDZCQUE2QixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDaEYsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDOUUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFFcEUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBb0U3RCwyQ0FBMkM7QUFDM0MsTUFBTSxPQUFPLHVCQUF1QjtJQXlCbEMsWUFDUyxhQUFzQyxFQUNyQyxjQUE4QixF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YUFDN0c7OztZQWhGUSx1QkFBdUI7WUFhdkIsY0FBYzt5Q0FpR2xCLE1BQU0sU0FBQyxTQUFTOzRDQUNoQixNQUFNLFNBQUMsV0FBVztZQWpIK0IsTUFBTTt5Q0FtSHZELE1BQU0sU0FBQyxTQUFTOzs7Z0NBbkJsQixZQUFZLFNBQUMsNEJBQTRCO2lDQUN6QyxZQUFZLFNBQUMsNkJBQTZCO2lDQUMxQyxTQUFTLFNBQUMsYUFBYSxFQUFFLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAyMiBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEVsZW1lbnRSZWYsIEluamVjdCwgTmdab25lLCBQTEFURk9STV9JRCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5zZXJ2aWNlJztcbmltcG9ydCB7IFVOSVFVRV9JRCwgVU5JUVVFX0lEX1BST1ZJREVSIH0gZnJvbSAnLi4vLi4vdXRpbHMvaWQtZ2VuZXJhdG9yL2lkLWdlbmVyYXRvci5zZXJ2aWNlJztcbmltcG9ydCB7IENsckFsaWdubWVudCB9IGZyb20gJy4uLy4uL3V0aWxzL3BvcG92ZXIvZW51bXMvYWxpZ25tZW50LmVudW0nO1xuaW1wb3J0IHsgQ2xyQXhpcyB9IGZyb20gJy4uLy4uL3V0aWxzL3BvcG92ZXIvZW51bXMvYXhpcy5lbnVtJztcbmltcG9ydCB7IENsclNpZGUgfSBmcm9tICcuLi8uLi91dGlscy9wb3BvdmVyL2VudW1zL3NpZGUuZW51bSc7XG5pbXBvcnQgeyBDbHJQb3BvdmVyUG9zaXRpb24gfSBmcm9tICcuLi8uLi91dGlscy9wb3BvdmVyL2ludGVyZmFjZXMvcG9wb3Zlci1wb3NpdGlvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ2xyUG9wb3ZlckV2ZW50c1NlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9wb3BvdmVyL3Byb3ZpZGVycy9wb3BvdmVyLWV2ZW50cy5zZXJ2aWNlJztcbmltcG9ydCB7IENsclBvcG92ZXJQb3NpdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9wb3BvdmVyL3Byb3ZpZGVycy9wb3BvdmVyLXBvc2l0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyUG9wb3ZlclRvZ2dsZVNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9wb3BvdmVyL3Byb3ZpZGVycy9wb3BvdmVyLXRvZ2dsZS5zZXJ2aWNlJztcbmltcG9ydCB7IENsckRhdGFncmlkQ29sdW1uVG9nZ2xlQnV0dG9uIH0gZnJvbSAnLi9kYXRhZ3JpZC1jb2x1bW4tdG9nZ2xlLWJ1dHRvbic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZVRpdGxlIH0gZnJvbSAnLi9kYXRhZ3JpZC1jb2x1bW4tdG9nZ2xlLXRpdGxlJztcbmltcG9ydCB7IERhdGFncmlkQ29sdW1uQ2hhbmdlcyB9IGZyb20gJy4vZW51bXMvY29sdW1uLWNoYW5nZXMuZW51bSc7XG5pbXBvcnQgeyBDb2x1bW5TdGF0ZSB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb2x1bW4tc3RhdGUuaW50ZXJmYWNlJztcbmltcG9ydCB7IENvbHVtbnNTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvY29sdW1ucy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLWNvbHVtbi10b2dnbGUnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxidXR0b25cbiAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBjbGFzcz1cImJ0biBidG4tc20gYnRuLWxpbmsgY29sdW1uLXRvZ2dsZS0tYWN0aW9uXCJcbiAgICAgIGNsclBvcG92ZXJBbmNob3JcbiAgICAgIGNsclBvcG92ZXJPcGVuQ2xvc2VCdXR0b25cbiAgICAgIFthdHRyLmFyaWEtY29udHJvbHNdPVwicG9wb3ZlcklkXCJcbiAgICAgIFthdHRyLmFyaWEtb3duc109XCJwb3BvdmVySWRcIlxuICAgICAgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5rZXlzLnBpY2tDb2x1bW5zXCJcbiAgICA+XG4gICAgICA8Y2RzLWljb24gc2hhcGU9XCJ2aWV3LWNvbHVtbnNcIiBhcmlhLWhpZGRlbj1cInRydWVcIiBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLmtleXMucGlja0NvbHVtbnNcIj48L2Nkcy1pY29uPlxuICAgIDwvYnV0dG9uPlxuICAgIDxkaXZcbiAgICAgIGNsYXNzPVwiY29sdW1uLXN3aXRjaFwiXG4gICAgICByb2xlPVwiZGlhbG9nXCJcbiAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiY29tbW9uU3RyaW5ncy5rZXlzLnNob3dDb2x1bW5zTWVudURlc2NyaXB0aW9uXCJcbiAgICAgIFtpZF09XCJwb3BvdmVySWRcIlxuICAgICAgY2xyRm9jdXNUcmFwXG4gICAgICAqY2xyUG9wb3ZlckNvbnRlbnQ9XCJvcGVuU3RhdGU7IGF0OiBzbWFydFBvc2l0aW9uOyBvdXRzaWRlQ2xpY2tUb0Nsb3NlOiB0cnVlOyBzY3JvbGxUb0Nsb3NlOiB0cnVlXCJcbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzPVwic3dpdGNoLWhlYWRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2xyLXNyLW9ubHlcIiB0YWJpbmRleD1cIi0xXCIgI2FsbFNlbGVjdGVkPnt7IGNvbW1vblN0cmluZ3Mua2V5cy5hbGxDb2x1bW5zU2VsZWN0ZWQgfX08L2Rpdj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFjdXN0b21Ub2dnbGVUaXRsZVwiPlxuICAgICAgICAgIDxoMj57eyBjb21tb25TdHJpbmdzLmtleXMuc2hvd0NvbHVtbnMgfX08L2gyPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWRnLWNvbHVtbi10b2dnbGUtdGl0bGVcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBjbGFzcz1cImJ0biBidG4tc20gYnRuLWxpbmsgdG9nZ2xlLXN3aXRjaC1jbG9zZS1idXR0b25cIlxuICAgICAgICAgIGNsclBvcG92ZXJDbG9zZUJ1dHRvblxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiY29tbW9uU3RyaW5ncy5rZXlzLmNsb3NlXCJcbiAgICAgICAgICBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLmtleXMuY2xvc2VcIlxuICAgICAgICA+XG4gICAgICAgICAgPGNkcy1pY29uIHNoYXBlPVwid2luZG93LWNsb3NlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5rZXlzLmNsb3NlXCI+PC9jZHMtaWNvbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICAgIDx1bCBjbGFzcz1cInN3aXRjaC1jb250ZW50IGxpc3QtdW5zdHlsZWRcIj5cbiAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBjb2x1bW5TdGF0ZSBvZiBoaWRlYWJsZUNvbHVtblN0YXRlczsgdHJhY2tCeTogdHJhY2tCeUZuXCI+XG4gICAgICAgICAgPGNsci1jaGVja2JveC13cmFwcGVyPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgIGNsckNoZWNrYm94XG4gICAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJoYXNPbmx5T25lVmlzaWJsZUNvbHVtbiAmJiAhY29sdW1uU3RhdGUuaGlkZGVuXCJcbiAgICAgICAgICAgICAgW25nTW9kZWxdPVwiIWNvbHVtblN0YXRlLmhpZGRlblwiXG4gICAgICAgICAgICAgIChuZ01vZGVsQ2hhbmdlKT1cInRvZ2dsZUNvbHVtblN0YXRlKGNvbHVtblN0YXRlLCAhJGV2ZW50KVwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGxhYmVsPlxuICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29sdW1uU3RhdGUudGl0bGVUZW1wbGF0ZVJlZlwiPjwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgIDwvY2xyLWNoZWNrYm94LXdyYXBwZXI+XG4gICAgICAgIDwvbGk+XG4gICAgICA8L3VsPlxuICAgICAgPGRpdiBjbGFzcz1cInN3aXRjaC1mb290ZXJcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWRnLWNvbHVtbi10b2dnbGUtYnV0dG9uXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8Y2xyLWRnLWNvbHVtbi10b2dnbGUtYnV0dG9uICpuZ0lmPVwiIWN1c3RvbVRvZ2dsZUJ1dHRvblwiIChjbHJBbGxTZWxlY3RlZCk9XCJhbGxDb2x1bW5zU2VsZWN0ZWQoKVwiPlxuICAgICAgICAgIHt7IGNvbW1vblN0cmluZ3Mua2V5cy5zZWxlY3RBbGwgfX1cbiAgICAgICAgPC9jbHItZGctY29sdW1uLXRvZ2dsZS1idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYCxcbiAgaG9zdDogeyAnW2NsYXNzLmNvbHVtbi1zd2l0Y2gtd3JhcHBlcl0nOiAndHJ1ZScsICdbY2xhc3MuYWN0aXZlXSc6ICdvcGVuU3RhdGUnIH0sXG4gIHByb3ZpZGVyczogW1VOSVFVRV9JRF9QUk9WSURFUiwgQ2xyUG9wb3ZlckV2ZW50c1NlcnZpY2UsIENsclBvcG92ZXJQb3NpdGlvblNlcnZpY2UsIENsclBvcG92ZXJUb2dnbGVTZXJ2aWNlXSxcbn0pXG4vKiogQGRlcHJlY2F0ZWQgc2luY2UgMi4wLCByZW1vdmUgaW4gMy4wICovXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGUge1xuICBwcml2YXRlIF9hbGxDb2x1bW5zVmlzaWJsZTogYm9vbGVhbjtcblxuICAvLyBTbWFydCBQb3BvdmVyXG4gIHB1YmxpYyBzbWFydFBvc2l0aW9uOiBDbHJQb3BvdmVyUG9zaXRpb24gPSB7XG4gICAgYXhpczogQ2xyQXhpcy5WRVJUSUNBTCxcbiAgICBzaWRlOiBDbHJTaWRlLkJFRk9SRSxcbiAgICBhbmNob3I6IENsckFsaWdubWVudC5TVEFSVCxcbiAgICBjb250ZW50OiBDbHJBbGlnbm1lbnQuU1RBUlQsXG4gIH07XG4gIHB1YmxpYyBvcGVuU3RhdGU6IGJvb2xlYW47XG5cbiAgQENvbnRlbnRDaGlsZChDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZVRpdGxlKSBjdXN0b21Ub2dnbGVUaXRsZTogQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVUaXRsZTtcbiAgQENvbnRlbnRDaGlsZChDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZUJ1dHRvbikgY3VzdG9tVG9nZ2xlQnV0dG9uOiBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZUJ1dHRvbjtcbiAgQFZpZXdDaGlsZCgnYWxsU2VsZWN0ZWQnLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSlcbiAgcHJpdmF0ZSBhbGxTZWxlY3RlZEVsZW1lbnQ6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xuXG4gIHB1YmxpYyBnZXQgYWxsQ29sdW1uc1Zpc2libGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2FsbENvbHVtbnNWaXNpYmxlO1xuICB9XG5cbiAgcHVibGljIHNldCBhbGxDb2x1bW5zVmlzaWJsZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2FsbENvbHVtbnNWaXNpYmxlID0gdmFsdWU7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBjb2x1bW5zU2VydmljZTogQ29sdW1uc1NlcnZpY2UsXG4gICAgQEluamVjdChVTklRVUVfSUQpIHB1YmxpYyBjb2x1bW5Td2l0Y2hJZDogc3RyaW5nLFxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogYW55LFxuICAgIHByaXZhdGUgem9uZTogTmdab25lLFxuICAgIEBJbmplY3QoVU5JUVVFX0lEKSBwdWJsaWMgcG9wb3ZlcklkOiBzdHJpbmdcbiAgKSB7fVxuXG4gIGdldCBoaWRlYWJsZUNvbHVtblN0YXRlcygpOiBDb2x1bW5TdGF0ZVtdIHtcbiAgICBjb25zdCBoaWRlYWJsZXMgPSB0aGlzLmNvbHVtbnNTZXJ2aWNlLmNvbHVtbnMuZmlsdGVyKGNvbHVtbiA9PiBjb2x1bW4udmFsdWUuaGlkZWFibGUpO1xuICAgIHJldHVybiBoaWRlYWJsZXMubWFwKGNvbHVtbiA9PiBjb2x1bW4udmFsdWUpO1xuICB9XG5cbiAgZ2V0IGhhc09ubHlPbmVWaXNpYmxlQ29sdW1uKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG5iTm9uSGlkZWFibGVDb2x1bW5zID0gdGhpcy5jb2x1bW5zU2VydmljZS5jb2x1bW5zLmxlbmd0aCAtIHRoaXMuaGlkZWFibGVDb2x1bW5TdGF0ZXMubGVuZ3RoO1xuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgcmV0dXJuIHRydWUgd2hlbiB0aGVyZSBpcyBubyBub24taGlkZWFibGUgY29sdW1ucy5cbiAgICByZXR1cm4gKFxuICAgICAgbmJOb25IaWRlYWJsZUNvbHVtbnMgPT09IDAgJiYgdGhpcy5oaWRlYWJsZUNvbHVtblN0YXRlcy5maWx0ZXIoY29sdW1uU3RhdGUgPT4gIWNvbHVtblN0YXRlLmhpZGRlbikubGVuZ3RoID09PSAxXG4gICAgKTtcbiAgfVxuXG4gIHRvZ2dsZUNvbHVtblN0YXRlKGNvbHVtblN0YXRlOiBDb2x1bW5TdGF0ZSwgZXZlbnQ6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBjb2x1bW5Ub1RvZ2dsZSA9IHRoaXMuY29sdW1uc1NlcnZpY2UuY29sdW1ucy5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi52YWx1ZSA9PT0gY29sdW1uU3RhdGUpWzBdO1xuICAgIHRoaXMuY29sdW1uc1NlcnZpY2UuZW1pdFN0YXRlQ2hhbmdlKGNvbHVtblRvVG9nZ2xlLCB7XG4gICAgICBoaWRkZW46IGV2ZW50LFxuICAgICAgY2hhbmdlczogW0RhdGFncmlkQ29sdW1uQ2hhbmdlcy5ISURERU5dLFxuICAgIH0pO1xuICB9XG5cbiAgdG9nZ2xlU3dpdGNoUGFuZWwoKSB7XG4gICAgdGhpcy5vcGVuU3RhdGUgPSAhdGhpcy5vcGVuU3RhdGU7XG4gIH1cblxuICBhbGxDb2x1bW5zU2VsZWN0ZWQoKSB7XG4gICAgdGhpcy5hbGxTZWxlY3RlZEVsZW1lbnQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICB9XG5cbiAgLy8gV2l0aG91dCB0cmFja2luZyB0aGUgY2hlY2tib3hlcyBnZXQgcmVyZW5kZXJlZCBvbiBtb2RlbCB1cGRhdGUsIHdoaWNoIGxlYWRzXG4gIC8vIHRvIGxvc3Mgb2YgZm9jdXMgYWZ0ZXIgY2hlY2tib3ggdG9nZ2xlLlxuICB0cmFja0J5Rm4oaW5kZXg6IG51bWJlcikge1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxufVxuIl19