/*
 * Copyright (c) 2016-2022 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { DOCUMENT } from '@angular/common';
import { Inject, Injectable, Renderer2 } from '@angular/core';
import { fromEvent } from 'rxjs';
import { filter } from 'rxjs/operators';
import { ClrPopoverToggleService } from './popover-toggle.service';
// https://github.com/angular/angular/issues/20351#issuecomment-344009887
/** @dynamic */
export class ClrPopoverEventsService {
    constructor(renderer, smartOpenService, document) {
        this.renderer = renderer;
        this.smartOpenService = smartOpenService;
        this.document = document;
        this.outsideClickClose = true;
        this.scrollToClose = true;
        this.subscriptions = [];
        this.subscriptions.push(smartOpenService.openChange.subscribe(open => {
            if (open) {
                this.addEscapeListener();
                this.addClickListener();
                this.addScrollListener();
            }
            else {
                this.removeAllEventListeners();
            }
        }), smartOpenService.getEventChange().subscribe(event => {
            // Remember the event that was used to open the content
            this.ignoredEvent = event;
        }));
    }
    addScrollListener() {
        if (this.scrollToClose) {
            this.documentScroller = fromEvent(this.document, 'scroll', { capture: true });
            this.scrollSubscription = this.documentScroller
                .pipe(filter(this.testForSmartPopoverContentContainer))
                .subscribe(() => {
                this.smartOpenService.open = false;
                this.setAnchorFocus();
            });
        }
        else {
            // I think this is where dynamic re-positioning will be added
            // Instead of testing like we do in the close pipe below
            // we need to switch positioning to use an observable and then
            // debounce the scroll events to recalculate content position in a performant way
            // For now, ignore scrolling events.
            return;
        }
    }
    removeScrollListener() {
        if (this.documentScroller) {
            this.scrollSubscription.unsubscribe();
            delete this.documentScroller;
        }
    }
    testForSmartPopoverContentContainer(event) {
        // Filter for the documentScroller observable event targets
        let target = event.target;
        // Walk up the DOM tree until we get to the element that is a direct child of the body.
        while (target.classList && target.parentElement.localName !== 'body') {
            target = target.parentElement;
        }
        // Target is the child element of body where the scroll events originated.
        // Return false and prevent the popover content container from closing for any scroll events inside a popover
        // content container.
        if (target.classList) {
            // check scroll events to see if they are happening in popover content or elsewhere
            return target.classList.contains('clr-popover-content') ? false : true;
        }
        else {
            // prevents it from closing right after first opening
            return false;
        }
    }
    addClickListener() {
        if (this.outsideClickClose) {
            this.documentClickListener = this.renderer.listen(this.document, 'click', (event) => {
                if (event === this.ignoredEvent) {
                    // Here we ignore the opening click event (w/o this content opens and immediately closes.
                    delete this.ignoredEvent;
                }
                else {
                    this.smartOpenService.open = false;
                    // Rather than a complex change to the focus trap I put focus on the element that was clicked
                    const clickedElement = event.target;
                    clickedElement.focus();
                }
            });
        }
    }
    removeClickListener() {
        if (this.outsideClickClose) {
            delete this.ignoredEvent;
            if (this.documentClickListener) {
                this.documentClickListener();
                delete this.documentClickListener;
            }
        }
    }
    addEscapeListener() {
        this.escapeListener = this.renderer.listen(this.document, 'keydown.escape', () => {
            this.smartOpenService.open = false;
            this.setAnchorFocus();
        });
    }
    removeEscapeListener() {
        if (this.escapeListener) {
            this.escapeListener();
            delete this.escapeListener;
        }
    }
    set anchorButtonRef(ref) {
        this._anchorButtonRef = ref;
    }
    get anchorButtonRef() {
        return this._anchorButtonRef;
    }
    set closeButtonRef(ref) {
        this._closeButtonRef = ref;
    }
    get closeButtonRef() {
        return this._closeButtonRef;
    }
    setCloseFocus() {
        this._closeButtonRef.nativeElement.focus();
    }
    setAnchorFocus() {
        this.anchorButtonRef.nativeElement.focus();
    }
    set contentRef(host) {
        this._contentRef = host;
    }
    get contentRef() {
        return this._contentRef;
    }
    removeAllEventListeners() {
        this.removeScrollListener();
        this.removeClickListener();
        this.removeEscapeListener();
    }
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
        this.removeAllEventListeners();
    }
}
ClrPopoverEventsService.decorators = [
    { type: Injectable }
];
ClrPopoverEventsService.ctorParameters = () => [
    { type: Renderer2 },
    { type: ClrPopoverToggleService },
    { type: HTMLDocument, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci1ldmVudHMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXIvc3JjL3V0aWxzL3BvcG92ZXIvcHJvdmlkZXJzL3BvcG92ZXItZXZlbnRzLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7R0FJRztBQUVILE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBQWMsTUFBTSxFQUFFLFVBQVUsRUFBYSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckYsT0FBTyxFQUFFLFNBQVMsRUFBNEIsTUFBTSxNQUFNLENBQUM7QUFDM0QsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXhDLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBRW5FLHlFQUF5RTtBQUN6RSxlQUFlO0FBRWYsTUFBTSxPQUFPLHVCQUF1QjtJQU9sQyxZQUNVLFFBQW1CLEVBQ25CLGdCQUF5QyxFQUN2QixRQUFzQjtRQUZ4QyxhQUFRLEdBQVIsUUFBUSxDQUFXO1FBQ25CLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBeUI7UUFDdkIsYUFBUSxHQUFSLFFBQVEsQ0FBYztRQVQzQyxzQkFBaUIsR0FBRyxJQUFJLENBQUM7UUFDekIsa0JBQWEsR0FBRyxJQUFJLENBQUM7UUFHcEIsa0JBQWEsR0FBbUIsRUFBRSxDQUFDO1FBT3pDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUNyQixnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzNDLElBQUksSUFBSSxFQUFFO2dCQUNSLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO2dCQUN6QixJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztnQkFDeEIsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7YUFD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QzFCLENBQUM7SUFDRCxJQUFXLFVBQVU7UUFDbkIsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDO0lBQzFCLENBQUM7SUFJTyx1QkFBdUI7UUFDN0IsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7UUFDNUIsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7UUFDM0IsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7SUFDOUIsQ0FBQztJQUNELFdBQVc7UUFDVCxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO1FBQ3JELElBQUksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDO0lBQ2pDLENBQUM7OztZQWpLRixVQUFVOzs7WUFSeUMsU0FBUztZQUlwRCx1QkFBdUI7WUFlUSxZQUFZLHVCQUEvQyxNQUFNLFNBQUMsUUFBUSIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAyMiBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgRWxlbWVudFJlZiwgSW5qZWN0LCBJbmplY3RhYmxlLCBPbkRlc3Ryb3ksIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50LCBPYnNlcnZhYmxlLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgQ2xyUG9wb3ZlclRvZ2dsZVNlcnZpY2UgfSBmcm9tICcuL3BvcG92ZXItdG9nZ2xlLnNlcnZpY2UnO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8yMDM1MSNpc3N1ZWNvbW1lbnQtMzQ0MDA5ODg3XG4vKiogQGR5bmFtaWMgKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDbHJQb3BvdmVyRXZlbnRzU2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHB1YmxpYyBvdXRzaWRlQ2xpY2tDbG9zZSA9IHRydWU7XG4gIHB1YmxpYyBzY3JvbGxUb0Nsb3NlID0gdHJ1ZTtcbiAgcHJpdmF0ZSBkb2N1bWVudENsaWNrTGlzdGVuZXI6ICgpID0+IHZvaWQ7XG4gIHB1YmxpYyBpZ25vcmVkRXZlbnQ6IGFueTtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIHNtYXJ0T3BlblNlcnZpY2U6IENsclBvcG92ZXJUb2dnbGVTZXJ2aWNlLFxuICAgIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgZG9jdW1lbnQ6IEhUTUxEb2N1bWVudFxuICApIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHNtYXJ0T3BlblNlcnZpY2Uub3BlbkNoYW5nZS5zdWJzY3JpYmUob3BlbiA9PiB7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgdGhpcy5hZGRFc2NhcGVMaXN0ZW5lcigpO1xuICAgICAgICAgIHRoaXMuYWRkQ2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICAgIHRoaXMuYWRkU2Nyb2xsTGlzdGVuZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgc21hcnRPcGVuU2VydmljZS5nZXRFdmVudENoYW5nZSgpLnN1YnNjcmliZShldmVudCA9PiB7XG4gICAgICAgIC8vIFJlbWVtYmVyIHRoZSBldmVudCB0aGF0IHdhcyB1c2VkIHRvIG9wZW4gdGhlIGNvbnRlbnRcbiAgICAgICAgdGhpcy5pZ25vcmVkRXZlbnQgPSBldmVudDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgc2Nyb2xsU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHB1YmxpYyBhZGRTY3JvbGxMaXN0ZW5lcigpIHtcbiAgICBpZiAodGhpcy5zY3JvbGxUb0Nsb3NlKSB7XG4gICAgICB0aGlzLmRvY3VtZW50U2Nyb2xsZXIgPSBmcm9tRXZlbnQodGhpcy5kb2N1bWVudCwgJ3Njcm9sbCcsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgIHRoaXMuc2Nyb2xsU3Vic2NyaXB0aW9uID0gdGhpcy5kb2N1bWVudFNjcm9sbGVyXG4gICAgICAgIC5waXBlKGZpbHRlcih0aGlzLnRlc3RGb3JTbWFydFBvcG92ZXJDb250ZW50Q29udGFpbmVyKSlcbiAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zbWFydE9wZW5TZXJ2aWNlLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnNldEFuY2hvckZvY3VzKCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJIHRoaW5rIHRoaXMgaXMgd2hlcmUgZHluYW1pYyByZS1wb3NpdGlvbmluZyB3aWxsIGJlIGFkZGVkXG4gICAgICAvLyBJbnN0ZWFkIG9mIHRlc3RpbmcgbGlrZSB3ZSBkbyBpbiB0aGUgY2xvc2UgcGlwZSBiZWxvd1xuICAgICAgLy8gd2UgbmVlZCB0byBzd2l0Y2ggcG9zaXRpb25pbmcgdG8gdXNlIGFuIG9ic2VydmFibGUgYW5kIHRoZW5cbiAgICAgIC8vIGRlYm91bmNlIHRoZSBzY3JvbGwgZXZlbnRzIHRvIHJlY2FsY3VsYXRlIGNvbnRlbnQgcG9zaXRpb24gaW4gYSBwZXJmb3JtYW50IHdheVxuICAgICAgLy8gRm9yIG5vdywgaWdub3JlIHNjcm9sbGluZyBldmVudHMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlbW92ZVNjcm9sbExpc3RlbmVyKCkge1xuICAgIGlmICh0aGlzLmRvY3VtZW50U2Nyb2xsZXIpIHtcbiAgICAgIHRoaXMuc2Nyb2xsU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICBkZWxldGUgdGhpcy5kb2N1bWVudFNjcm9sbGVyO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdGVzdEZvclNtYXJ0UG9wb3ZlckNvbnRlbnRDb250YWluZXIoZXZlbnQ6IEV2ZW50KTogYm9vbGVhbiB7XG4gICAgLy8gRmlsdGVyIGZvciB0aGUgZG9jdW1lbnRTY3JvbGxlciBvYnNlcnZhYmxlIGV2ZW50IHRhcmdldHNcbiAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuXG4gICAgLy8gV2FsayB1cCB0aGUgRE9NIHRyZWUgdW50aWwgd2UgZ2V0IHRvIHRoZSBlbGVtZW50IHRoYXQgaXMgYSBkaXJlY3QgY2hpbGQgb2YgdGhlIGJvZHkuXG4gICAgd2hpbGUgKHRhcmdldC5jbGFzc0xpc3QgJiYgdGFyZ2V0LnBhcmVudEVsZW1lbnQubG9jYWxOYW1lICE9PSAnYm9keScpIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnRFbGVtZW50O1xuICAgIH1cblxuICAgIC8vIFRhcmdldCBpcyB0aGUgY2hpbGQgZWxlbWVudCBvZiBib2R5IHdoZXJlIHRoZSBzY3JvbGwgZXZlbnRzIG9yaWdpbmF0ZWQuXG4gICAgLy8gUmV0dXJuIGZhbHNlIGFuZCBwcmV2ZW50IHRoZSBwb3BvdmVyIGNvbnRlbnQgY29udGFpbmVyIGZyb20gY2xvc2luZyBmb3IgYW55IHNjcm9sbCBldmVudHMgaW5zaWRlIGEgcG9wb3ZlclxuICAgIC8vIGNvbnRlbnQgY29udGFpbmVyLlxuICAgIGlmICh0YXJnZXQuY2xhc3NMaXN0KSB7XG4gICAgICAvLyBjaGVjayBzY3JvbGwgZXZlbnRzIHRvIHNlZSBpZiB0aGV5IGFyZSBoYXBwZW5pbmcgaW4gcG9wb3ZlciBjb250ZW50IG9yIGVsc2V3aGVyZVxuICAgICAgcmV0dXJuIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2Nsci1wb3BvdmVyLWNvbnRlbnQnKSA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcHJldmVudHMgaXQgZnJvbSBjbG9zaW5nIHJpZ2h0IGFmdGVyIGZpcnN0IG9wZW5pbmdcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYWRkQ2xpY2tMaXN0ZW5lcigpIHtcbiAgICBpZiAodGhpcy5vdXRzaWRlQ2xpY2tDbG9zZSkge1xuICAgICAgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLmRvY3VtZW50LCAnY2xpY2snLCAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50ID09PSB0aGlzLmlnbm9yZWRFdmVudCkge1xuICAgICAgICAgIC8vIEhlcmUgd2UgaWdub3JlIHRoZSBvcGVuaW5nIGNsaWNrIGV2ZW50ICh3L28gdGhpcyBjb250ZW50IG9wZW5zIGFuZCBpbW1lZGlhdGVseSBjbG9zZXMuXG4gICAgICAgICAgZGVsZXRlIHRoaXMuaWdub3JlZEV2ZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc21hcnRPcGVuU2VydmljZS5vcGVuID0gZmFsc2U7XG4gICAgICAgICAgLy8gUmF0aGVyIHRoYW4gYSBjb21wbGV4IGNoYW5nZSB0byB0aGUgZm9jdXMgdHJhcCBJIHB1dCBmb2N1cyBvbiB0aGUgZWxlbWVudCB0aGF0IHdhcyBjbGlja2VkXG4gICAgICAgICAgY29uc3QgY2xpY2tlZEVsZW1lbnQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgY2xpY2tlZEVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlbW92ZUNsaWNrTGlzdGVuZXIoKSB7XG4gICAgaWYgKHRoaXMub3V0c2lkZUNsaWNrQ2xvc2UpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmlnbm9yZWRFdmVudDtcbiAgICAgIGlmICh0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICBkZWxldGUgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBlc2NhcGVMaXN0ZW5lcjogKCkgPT4gdm9pZDtcbiAgcHVibGljIGFkZEVzY2FwZUxpc3RlbmVyKCkge1xuICAgIHRoaXMuZXNjYXBlTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLmRvY3VtZW50LCAna2V5ZG93bi5lc2NhcGUnLCAoKSA9PiB7XG4gICAgICB0aGlzLnNtYXJ0T3BlblNlcnZpY2Uub3BlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5zZXRBbmNob3JGb2N1cygpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUVzY2FwZUxpc3RlbmVyKCkge1xuICAgIGlmICh0aGlzLmVzY2FwZUxpc3RlbmVyKSB7XG4gICAgICB0aGlzLmVzY2FwZUxpc3RlbmVyKCk7XG4gICAgICBkZWxldGUgdGhpcy5lc2NhcGVMaXN0ZW5lcjtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9hbmNob3JCdXR0b25SZWY6IEVsZW1lbnRSZWY7XG4gIHB1YmxpYyBzZXQgYW5jaG9yQnV0dG9uUmVmKHJlZjogRWxlbWVudFJlZikge1xuICAgIHRoaXMuX2FuY2hvckJ1dHRvblJlZiA9IHJlZjtcbiAgfVxuICBwdWJsaWMgZ2V0IGFuY2hvckJ1dHRvblJlZigpOiBFbGVtZW50UmVmIHtcbiAgICByZXR1cm4gdGhpcy5fYW5jaG9yQnV0dG9uUmVmO1xuICB9XG5cbiAgcHJpdmF0ZSBfY2xvc2VCdXR0b25SZWY6IEVsZW1lbnRSZWY7XG4gIHB1YmxpYyBzZXQgY2xvc2VCdXR0b25SZWYocmVmOiBFbGVtZW50UmVmKSB7XG4gICAgdGhpcy5fY2xvc2VCdXR0b25SZWYgPSByZWY7XG4gIH1cbiAgcHVibGljIGdldCBjbG9zZUJ1dHRvblJlZigpOiBFbGVtZW50UmVmIHtcbiAgICByZXR1cm4gdGhpcy5fY2xvc2VCdXR0b25SZWY7XG4gIH1cblxuICBwdWJsaWMgc2V0Q2xvc2VGb2N1cygpOiB2b2lkIHtcbiAgICB0aGlzLl9jbG9zZUJ1dHRvblJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gIH1cblxuICBwdWJsaWMgc2V0QW5jaG9yRm9jdXMoKTogdm9pZCB7XG4gICAgdGhpcy5hbmNob3JCdXR0b25SZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICB9XG5cbiAgcHJpdmF0ZSBfY29udGVudFJlZjogRWxlbWVudFJlZjtcbiAgcHVibGljIHNldCBjb250ZW50UmVmKGhvc3Q6IEVsZW1lbnRSZWYpIHtcbiAgICB0aGlzLl9jb250ZW50UmVmID0gaG9zdDtcbiAgfVxuICBwdWJsaWMgZ2V0IGNvbnRlbnRSZWYoKTogRWxlbWVudFJlZiB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRSZWY7XG4gIH1cblxuICBwcml2YXRlIGRvY3VtZW50U2Nyb2xsZXI6IE9ic2VydmFibGU8RXZlbnQ+O1xuXG4gIHByaXZhdGUgcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5yZW1vdmVTY3JvbGxMaXN0ZW5lcigpO1xuICAgIHRoaXMucmVtb3ZlQ2xpY2tMaXN0ZW5lcigpO1xuICAgIHRoaXMucmVtb3ZlRXNjYXBlTGlzdGVuZXIoKTtcbiAgfVxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICAgIHRoaXMucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxufVxuIl19