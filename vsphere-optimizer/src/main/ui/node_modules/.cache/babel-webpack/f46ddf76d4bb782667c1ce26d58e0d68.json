{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar t;\n\nconst i = window,\n      s = i.trustedTypes,\n      e = s ? s.createPolicy(\"lit-html\", {\n  createHTML: t => t\n}) : void 0,\n      o = \"$lit$\",\n      n = `lit$${(Math.random() + \"\").slice(9)}$`,\n      l = \"?\" + n,\n      h = `<${l}>`,\n      r = document,\n      u = () => r.createComment(\"\"),\n      d = t => null === t || \"object\" != typeof t && \"function\" != typeof t,\n      c = Array.isArray,\n      v = t => c(t) || \"function\" == typeof (null == t ? void 0 : t[Symbol.iterator]),\n      a = \"[ \\t\\n\\f\\r]\",\n      f = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g,\n      _ = /-->/g,\n      m = />/g,\n      p = RegExp(`>|${a}(?:([^\\\\s\"'>=/]+)(${a}*=${a}*(?:[^ \\t\\n\\f\\r\"'\\`<>=]|(\"|')|))|$)`, \"g\"),\n      g = /'/g,\n      $ = /\"/g,\n      y = /^(?:script|style|textarea|title)$/i,\n      w = t => (i, ...s) => ({\n  _$litType$: t,\n  strings: i,\n  values: s\n}),\n      x = w(1),\n      b = w(2),\n      T = Symbol.for(\"lit-noChange\"),\n      A = Symbol.for(\"lit-nothing\"),\n      E = new WeakMap(),\n      C = r.createTreeWalker(r, 129, null, !1);\n\nfunction P(t, i) {\n  if (!Array.isArray(t) || !t.hasOwnProperty(\"raw\")) throw Error(\"invalid template strings array\");\n  return void 0 !== e ? e.createHTML(i) : i;\n}\n\nconst V = (t, i) => {\n  const s = t.length - 1,\n        e = [];\n  let l,\n      r = 2 === i ? \"<svg>\" : \"\",\n      u = f;\n\n  for (let i = 0; i < s; i++) {\n    const s = t[i];\n    let d,\n        c,\n        v = -1,\n        a = 0;\n\n    for (; a < s.length && (u.lastIndex = a, c = u.exec(s), null !== c);) a = u.lastIndex, u === f ? \"!--\" === c[1] ? u = _ : void 0 !== c[1] ? u = m : void 0 !== c[2] ? (y.test(c[2]) && (l = RegExp(\"</\" + c[2], \"g\")), u = p) : void 0 !== c[3] && (u = p) : u === p ? \">\" === c[0] ? (u = null != l ? l : f, v = -1) : void 0 === c[1] ? v = -2 : (v = u.lastIndex - c[2].length, d = c[1], u = void 0 === c[3] ? p : '\"' === c[3] ? $ : g) : u === $ || u === g ? u = p : u === _ || u === m ? u = f : (u = p, l = void 0);\n\n    const w = u === p && t[i + 1].startsWith(\"/>\") ? \" \" : \"\";\n    r += u === f ? s + h : v >= 0 ? (e.push(d), s.slice(0, v) + o + s.slice(v) + n + w) : s + n + (-2 === v ? (e.push(void 0), i) : w);\n  }\n\n  return [P(t, r + (t[s] || \"<?>\") + (2 === i ? \"</svg>\" : \"\")), e];\n};\n\nclass N {\n  constructor({\n    strings: t,\n    _$litType$: i\n  }, e) {\n    let h;\n    this.parts = [];\n    let r = 0,\n        d = 0;\n    const c = t.length - 1,\n          v = this.parts,\n          [a, f] = V(t, i);\n\n    if (this.el = N.createElement(a, e), C.currentNode = this.el.content, 2 === i) {\n      const t = this.el.content,\n            i = t.firstChild;\n      i.remove(), t.append(...i.childNodes);\n    }\n\n    for (; null !== (h = C.nextNode()) && v.length < c;) {\n      if (1 === h.nodeType) {\n        if (h.hasAttributes()) {\n          const t = [];\n\n          for (const i of h.getAttributeNames()) if (i.endsWith(o) || i.startsWith(n)) {\n            const s = f[d++];\n\n            if (t.push(i), void 0 !== s) {\n              const t = h.getAttribute(s.toLowerCase() + o).split(n),\n                    i = /([.?@])?(.*)/.exec(s);\n              v.push({\n                type: 1,\n                index: r,\n                name: i[2],\n                strings: t,\n                ctor: \".\" === i[1] ? H : \"?\" === i[1] ? L : \"@\" === i[1] ? z : k\n              });\n            } else v.push({\n              type: 6,\n              index: r\n            });\n          }\n\n          for (const i of t) h.removeAttribute(i);\n        }\n\n        if (y.test(h.tagName)) {\n          const t = h.textContent.split(n),\n                i = t.length - 1;\n\n          if (i > 0) {\n            h.textContent = s ? s.emptyScript : \"\";\n\n            for (let s = 0; s < i; s++) h.append(t[s], u()), C.nextNode(), v.push({\n              type: 2,\n              index: ++r\n            });\n\n            h.append(t[i], u());\n          }\n        }\n      } else if (8 === h.nodeType) if (h.data === l) v.push({\n        type: 2,\n        index: r\n      });else {\n        let t = -1;\n\n        for (; -1 !== (t = h.data.indexOf(n, t + 1));) v.push({\n          type: 7,\n          index: r\n        }), t += n.length - 1;\n      }\n\n      r++;\n    }\n  }\n\n  static createElement(t, i) {\n    const s = r.createElement(\"template\");\n    return s.innerHTML = t, s;\n  }\n\n}\n\nfunction S(t, i, s = t, e) {\n  var o, n, l, h;\n  if (i === T) return i;\n  let r = void 0 !== e ? null === (o = s._$Co) || void 0 === o ? void 0 : o[e] : s._$Cl;\n  const u = d(i) ? void 0 : i._$litDirective$;\n  return (null == r ? void 0 : r.constructor) !== u && (null === (n = null == r ? void 0 : r._$AO) || void 0 === n || n.call(r, !1), void 0 === u ? r = void 0 : (r = new u(t), r._$AT(t, s, e)), void 0 !== e ? (null !== (l = (h = s)._$Co) && void 0 !== l ? l : h._$Co = [])[e] = r : s._$Cl = r), void 0 !== r && (i = S(t, r._$AS(t, i.values), r, e)), i;\n}\n\nclass M {\n  constructor(t, i) {\n    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = i;\n  }\n\n  get parentNode() {\n    return this._$AM.parentNode;\n  }\n\n  get _$AU() {\n    return this._$AM._$AU;\n  }\n\n  u(t) {\n    var i;\n    const {\n      el: {\n        content: s\n      },\n      parts: e\n    } = this._$AD,\n          o = (null !== (i = null == t ? void 0 : t.creationScope) && void 0 !== i ? i : r).importNode(s, !0);\n    C.currentNode = o;\n    let n = C.nextNode(),\n        l = 0,\n        h = 0,\n        u = e[0];\n\n    for (; void 0 !== u;) {\n      if (l === u.index) {\n        let i;\n        2 === u.type ? i = new R(n, n.nextSibling, this, t) : 1 === u.type ? i = new u.ctor(n, u.name, u.strings, this, t) : 6 === u.type && (i = new Z(n, this, t)), this._$AV.push(i), u = e[++h];\n      }\n\n      l !== (null == u ? void 0 : u.index) && (n = C.nextNode(), l++);\n    }\n\n    return C.currentNode = r, o;\n  }\n\n  v(t) {\n    let i = 0;\n\n    for (const s of this._$AV) void 0 !== s && (void 0 !== s.strings ? (s._$AI(t, s, i), i += s.strings.length - 2) : s._$AI(t[i])), i++;\n  }\n\n}\n\nclass R {\n  constructor(t, i, s, e) {\n    var o;\n    this.type = 2, this._$AH = A, this._$AN = void 0, this._$AA = t, this._$AB = i, this._$AM = s, this.options = e, this._$Cp = null === (o = null == e ? void 0 : e.isConnected) || void 0 === o || o;\n  }\n\n  get _$AU() {\n    var t, i;\n    return null !== (i = null === (t = this._$AM) || void 0 === t ? void 0 : t._$AU) && void 0 !== i ? i : this._$Cp;\n  }\n\n  get parentNode() {\n    let t = this._$AA.parentNode;\n    const i = this._$AM;\n    return void 0 !== i && 11 === (null == t ? void 0 : t.nodeType) && (t = i.parentNode), t;\n  }\n\n  get startNode() {\n    return this._$AA;\n  }\n\n  get endNode() {\n    return this._$AB;\n  }\n\n  _$AI(t, i = this) {\n    t = S(this, t, i), d(t) ? t === A || null == t || \"\" === t ? (this._$AH !== A && this._$AR(), this._$AH = A) : t !== this._$AH && t !== T && this._(t) : void 0 !== t._$litType$ ? this.g(t) : void 0 !== t.nodeType ? this.$(t) : v(t) ? this.T(t) : this._(t);\n  }\n\n  k(t) {\n    return this._$AA.parentNode.insertBefore(t, this._$AB);\n  }\n\n  $(t) {\n    this._$AH !== t && (this._$AR(), this._$AH = this.k(t));\n  }\n\n  _(t) {\n    this._$AH !== A && d(this._$AH) ? this._$AA.nextSibling.data = t : this.$(r.createTextNode(t)), this._$AH = t;\n  }\n\n  g(t) {\n    var i;\n    const {\n      values: s,\n      _$litType$: e\n    } = t,\n          o = \"number\" == typeof e ? this._$AC(t) : (void 0 === e.el && (e.el = N.createElement(P(e.h, e.h[0]), this.options)), e);\n    if ((null === (i = this._$AH) || void 0 === i ? void 0 : i._$AD) === o) this._$AH.v(s);else {\n      const t = new M(o, this),\n            i = t.u(this.options);\n      t.v(s), this.$(i), this._$AH = t;\n    }\n  }\n\n  _$AC(t) {\n    let i = E.get(t.strings);\n    return void 0 === i && E.set(t.strings, i = new N(t)), i;\n  }\n\n  T(t) {\n    c(this._$AH) || (this._$AH = [], this._$AR());\n    const i = this._$AH;\n    let s,\n        e = 0;\n\n    for (const o of t) e === i.length ? i.push(s = new R(this.k(u()), this.k(u()), this, this.options)) : s = i[e], s._$AI(o), e++;\n\n    e < i.length && (this._$AR(s && s._$AB.nextSibling, e), i.length = e);\n  }\n\n  _$AR(t = this._$AA.nextSibling, i) {\n    var s;\n\n    for (null === (s = this._$AP) || void 0 === s || s.call(this, !1, !0, i); t && t !== this._$AB;) {\n      const i = t.nextSibling;\n      t.remove(), t = i;\n    }\n  }\n\n  setConnected(t) {\n    var i;\n    void 0 === this._$AM && (this._$Cp = t, null === (i = this._$AP) || void 0 === i || i.call(this, t));\n  }\n\n}\n\nclass k {\n  constructor(t, i, s, e, o) {\n    this.type = 1, this._$AH = A, this._$AN = void 0, this.element = t, this.name = i, this._$AM = e, this.options = o, s.length > 2 || \"\" !== s[0] || \"\" !== s[1] ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = A;\n  }\n\n  get tagName() {\n    return this.element.tagName;\n  }\n\n  get _$AU() {\n    return this._$AM._$AU;\n  }\n\n  _$AI(t, i = this, s, e) {\n    const o = this.strings;\n    let n = !1;\n    if (void 0 === o) t = S(this, t, i, 0), n = !d(t) || t !== this._$AH && t !== T, n && (this._$AH = t);else {\n      const e = t;\n      let l, h;\n\n      for (t = o[0], l = 0; l < o.length - 1; l++) h = S(this, e[s + l], i, l), h === T && (h = this._$AH[l]), n || (n = !d(h) || h !== this._$AH[l]), h === A ? t = A : t !== A && (t += (null != h ? h : \"\") + o[l + 1]), this._$AH[l] = h;\n    }\n    n && !e && this.j(t);\n  }\n\n  j(t) {\n    t === A ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t ? t : \"\");\n  }\n\n}\n\nclass H extends k {\n  constructor() {\n    super(...arguments), this.type = 3;\n  }\n\n  j(t) {\n    this.element[this.name] = t === A ? void 0 : t;\n  }\n\n}\n\nconst I = s ? s.emptyScript : \"\";\n\nclass L extends k {\n  constructor() {\n    super(...arguments), this.type = 4;\n  }\n\n  j(t) {\n    t && t !== A ? this.element.setAttribute(this.name, I) : this.element.removeAttribute(this.name);\n  }\n\n}\n\nclass z extends k {\n  constructor(t, i, s, e, o) {\n    super(t, i, s, e, o), this.type = 5;\n  }\n\n  _$AI(t, i = this) {\n    var s;\n    if ((t = null !== (s = S(this, t, i, 0)) && void 0 !== s ? s : A) === T) return;\n    const e = this._$AH,\n          o = t === A && e !== A || t.capture !== e.capture || t.once !== e.once || t.passive !== e.passive,\n          n = t !== A && (e === A || o);\n    o && this.element.removeEventListener(this.name, this, e), n && this.element.addEventListener(this.name, this, t), this._$AH = t;\n  }\n\n  handleEvent(t) {\n    var i, s;\n    \"function\" == typeof this._$AH ? this._$AH.call(null !== (s = null === (i = this.options) || void 0 === i ? void 0 : i.host) && void 0 !== s ? s : this.element, t) : this._$AH.handleEvent(t);\n  }\n\n}\n\nclass Z {\n  constructor(t, i, s) {\n    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = i, this.options = s;\n  }\n\n  get _$AU() {\n    return this._$AM._$AU;\n  }\n\n  _$AI(t) {\n    S(this, t);\n  }\n\n}\n\nconst j = {\n  O: o,\n  P: n,\n  A: l,\n  C: 1,\n  M: V,\n  L: M,\n  D: v,\n  R: S,\n  I: R,\n  V: k,\n  H: L,\n  N: z,\n  U: H,\n  F: Z\n},\n      B = i.litHtmlPolyfillSupport;\nnull == B || B(N, R), (null !== (t = i.litHtmlVersions) && void 0 !== t ? t : i.litHtmlVersions = []).push(\"2.7.5\");\n\nconst D = (t, i, s) => {\n  var e, o;\n  const n = null !== (e = null == s ? void 0 : s.renderBefore) && void 0 !== e ? e : i;\n  let l = n._$litPart$;\n\n  if (void 0 === l) {\n    const t = null !== (o = null == s ? void 0 : s.renderBefore) && void 0 !== o ? o : null;\n    n._$litPart$ = l = new R(i.insertBefore(u(), t), t, void 0, null != s ? s : {});\n  }\n\n  return l._$AI(t), l;\n};\n\nexport { j as _$LH, x as html, T as noChange, A as nothing, D as render, b as svg }; //# sourceMappingURL=lit-html.js.map","map":null,"metadata":{},"sourceType":"module"}