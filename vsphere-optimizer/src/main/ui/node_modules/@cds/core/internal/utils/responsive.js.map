{"version":3,"file":"responsive.js","sources":["../../../../src/internal/utils/responsive.ts"],"sourcesContent":["/*\n * Copyright (c) 2016-2022 VMware, Inc. All Rights Reserved.\n * This software is released under MIT license.\n * The full license information can be found in LICENSE in the root directory of this project.\n */\nexport function elementResize(element, callbackFn) {\n    const observer = new ResizeObserver(() => {\n        // We wrap the callback in requestAnimationFrame to\n        // avoid the error of \"ResizeObserver loop limit exceeded\".\n        window.requestAnimationFrame(() => callbackFn());\n    });\n    observer.observe(element);\n    observer.__testTrigger = callbackFn; // hook to trigger resize event as ResizeObserver does not run in headless chrome.\n    return observer;\n}\nexport function elementVisible(element, callbackFn) {\n    const observer = new IntersectionObserver(entries => {\n        if (entries[0].isIntersecting === true) {\n            callbackFn();\n        }\n    }, { threshold: [0] });\n    observer.observe(element);\n    return observer;\n}\n/**\n * Given a ResponsiveComponent this function will loop through a list of layout\n * options and change the layout of the component until the components layout\n * condition is satisfied.\n */\nexport function updateComponentLayout(component, layoutConfig, fn) {\n    return elementResize(component, () => {\n        if (component.responsive) {\n            calculateOptimalLayout(component, layoutConfig).then(updated => {\n                if (updated) {\n                    fn();\n                }\n            });\n        }\n    });\n}\nfunction calculateOptimalLayout(component, layoutConfig) {\n    return component.updateComplete.then(() => {\n        const currentLayout = component.layout;\n        component.layout = layoutConfig.layouts[0];\n        return layoutConfig.layouts\n            .reduce((prev, next) => {\n            return prev.then(() => {\n                if (component.layout === layoutConfig.initialLayout) {\n                    return next;\n                }\n                else {\n                    const prev = component.layout;\n                    component.layout = next;\n                    return component.updateComplete.then(() => {\n                        component.layout = component.layoutStable ? component.layout : prev;\n                        return next;\n                    });\n                }\n            });\n        }, Promise.resolve(layoutConfig.layouts[0]))\n            .then(() => currentLayout !== component.layout);\n    });\n}\n"],"names":["elementResize","element","callbackFn","observer","ResizeObserver","window","requestAnimationFrame","observe","__testTrigger","elementVisible","IntersectionObserver","entries","isIntersecting","threshold","updateComponentLayout","component","layoutConfig","fn","responsive","updateComplete","then","currentLayout","layout","layouts","reduce","prev","next","initialLayout","layoutStable","Promise","resolve","calculateOptimalLayout","updated"],"mappings":"AAKO,SAASA,EAAcC,EAASC,GACnC,MAAMC,EAAW,IAAIC,gBAAe,KAGhCC,OAAOC,uBAAsB,IAAMJ,SAIvC,OAFAC,EAASI,QAAQN,GACjBE,EAASK,cAAgBN,EAClBC,EAEJ,SAASM,EAAeR,EAASC,GACpC,MAAMC,EAAW,IAAIO,sBAAqBC,KACJ,IAA9BA,EAAQ,GAAGC,gBACXV,MAEL,CAAEW,UAAW,CAAC,KAEjB,OADAV,EAASI,QAAQN,GACVE,EAOJ,SAASW,EAAsBC,EAAWC,EAAcC,GAC3D,OAAOjB,EAAce,GAAW,KACxBA,EAAUG,YAStB,SAAgCH,EAAWC,GACvC,OAAOD,EAAUI,eAAeC,MAAK,KACjC,MAAMC,EAAgBN,EAAUO,OAEhC,OADAP,EAAUO,OAASN,EAAaO,QAAQ,GACjCP,EAAaO,QACfC,QAAO,CAACC,EAAMC,IACRD,EAAKL,MAAK,KACb,GAAIL,EAAUO,SAAWN,EAAaW,cAClC,OAAOD,EAEN,CACD,MAAMD,EAAOV,EAAUO,OAEvB,OADAP,EAAUO,OAASI,EACZX,EAAUI,eAAeC,MAAK,KACjCL,EAAUO,OAASP,EAAUa,aAAeb,EAAUO,OAASG,EACxDC,UAIpBG,QAAQC,QAAQd,EAAaO,QAAQ,KACnCH,MAAK,IAAMC,IAAkBN,EAAUO,YA5BxCS,CAAuBhB,EAAWC,GAAcI,MAAKY,IAC7CA,GACAf"}